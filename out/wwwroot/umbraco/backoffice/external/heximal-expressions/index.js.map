{"version":3,"file":"index.js","sources":["../../../node_modules/@heximal/expressions/lib/constants.js","../../../node_modules/@heximal/expressions/lib/tokenizer.js","../../../node_modules/@heximal/expressions/lib/parser.js","../../../node_modules/@heximal/expressions/lib/ast_factory.js","../../../node_modules/@heximal/expressions/lib/eval.js"],"sourcesContent":["/*\n * @license\n * Portions Copyright (c) 2013, the Dart project authors.\n */\nexport const KEYWORDS = ['this'];\nexport const UNARY_OPERATORS = ['+', '-', '!'];\nexport const BINARY_OPERATORS = [\n    '=',\n    '+',\n    '-',\n    '*',\n    '/',\n    '%',\n    '^',\n    '==',\n    '!=',\n    '>',\n    '<',\n    '>=',\n    '<=',\n    '||',\n    '&&',\n    '??',\n    '&',\n    '===',\n    '!==',\n    '|',\n    '|>',\n];\nexport const PRECEDENCE = {\n    '!': 0,\n    ':': 0,\n    ',': 0,\n    ')': 0,\n    ']': 0,\n    '}': 0,\n    '|>': 1,\n    '?': 2,\n    '??': 3,\n    '||': 4,\n    '&&': 5,\n    '|': 6,\n    '^': 7,\n    '&': 8,\n    // equality\n    '!=': 9,\n    '==': 9,\n    '!==': 9,\n    '===': 9,\n    // relational\n    '>=': 10,\n    '>': 10,\n    '<=': 10,\n    '<': 10,\n    // additive\n    '+': 11,\n    '-': 11,\n    // multiplicative\n    '%': 12,\n    '/': 12,\n    '*': 12,\n    // postfix\n    '(': 13,\n    '[': 13,\n    '.': 13,\n    '{': 13, // not sure this is correct\n};\nexport const POSTFIX_PRECEDENCE = 13;\n//# sourceMappingURL=constants.js.map","/*\n * @license\n * Portions Copyright (c) 2013, the Dart project authors.\n */\nimport { KEYWORDS, POSTFIX_PRECEDENCE, PRECEDENCE } from './constants.js';\nconst TWO_CHAR_OPS = ['==', '!=', '<=', '>=', '||', '&&', '??', '|>'];\nconst THREE_CHAR_OPS = ['===', '!=='];\nexport var Kind;\n(function (Kind) {\n    Kind[Kind[\"STRING\"] = 1] = \"STRING\";\n    Kind[Kind[\"IDENTIFIER\"] = 2] = \"IDENTIFIER\";\n    Kind[Kind[\"DOT\"] = 3] = \"DOT\";\n    Kind[Kind[\"COMMA\"] = 4] = \"COMMA\";\n    Kind[Kind[\"COLON\"] = 5] = \"COLON\";\n    Kind[Kind[\"INTEGER\"] = 6] = \"INTEGER\";\n    Kind[Kind[\"DECIMAL\"] = 7] = \"DECIMAL\";\n    Kind[Kind[\"OPERATOR\"] = 8] = \"OPERATOR\";\n    Kind[Kind[\"GROUPER\"] = 9] = \"GROUPER\";\n    Kind[Kind[\"KEYWORD\"] = 10] = \"KEYWORD\";\n    Kind[Kind[\"ARROW\"] = 11] = \"ARROW\";\n})(Kind || (Kind = {}));\nexport const token = (kind, value, precedence = 0) => ({\n    kind,\n    value,\n    precedence,\n});\nconst isWhitespace = (ch) => ch === 9 /* \\t */ ||\n    ch === 10 /* \\n */ ||\n    ch === 13 /* \\r */ ||\n    ch === 32; /* space */\n// TODO(justinfagnani): allow code points > 127\nconst isIdentOrKeywordStart = (ch) => ch === 95 /* _ */ ||\n    ch === 36 /* $ */ ||\n    // ch &= ~32 puts ch into the range [65,90] [A-Z] only if ch was already in\n    // the that range or in the range [97,122] [a-z]. We must mutate ch only after\n    // checking other characters, thus the comma operator.\n    ((ch &= ~32), 65 /* A */ <= ch && ch <= 90); /* Z */\n// TODO(justinfagnani): allow code points > 127\nconst isIdentifier = (ch) => isIdentOrKeywordStart(ch) || isNumber(ch);\nconst isKeyword = (str) => KEYWORDS.indexOf(str) !== -1;\nconst isQuote = (ch) => ch === 34 /* \" */ || ch === 39; /* ' */\nconst isNumber = (ch) => 48 /* 0 */ <= ch && ch <= 57; /* 9 */\nconst isOperator = (ch) => ch === 43 /* + */ ||\n    ch === 45 /* - */ ||\n    ch === 42 /* * */ ||\n    ch === 47 /* / */ ||\n    ch === 33 /* ! */ ||\n    ch === 38 /* & */ ||\n    ch === 37 /* % */ ||\n    ch === 60 /* < */ ||\n    ch === 61 /* = */ ||\n    ch === 62 /* > */ ||\n    ch === 63 /* ? */ ||\n    ch === 94 /* ^ */ ||\n    ch === 124; /* | */\nconst _isGrouper = (ch) => ch === 40 /* ( */ ||\n    ch === 41 /* ) */ ||\n    ch === 91 /* [ */ ||\n    ch === 93 /* ] */ ||\n    ch === 123 /* { */ ||\n    ch === 125; /* } */\nconst escapeString = (str) => str.replace(/\\\\(.)/g, (_match, group) => {\n    switch (group) {\n        case 'n':\n            return '\\n';\n        case 'r':\n            return '\\r';\n        case 't':\n            return '\\t';\n        case 'b':\n            return '\\b';\n        case 'f':\n            return '\\f';\n        default:\n            return group;\n    }\n});\nexport class Tokenizer {\n    #input;\n    #index = -1;\n    #tokenStart = 0;\n    #next;\n    constructor(input) {\n        this.#input = input;\n        this.#advance();\n    }\n    nextToken() {\n        while (isWhitespace(this.#next)) {\n            this.#advance(true);\n        }\n        if (isQuote(this.#next))\n            return this.#tokenizeString();\n        if (isIdentOrKeywordStart(this.#next)) {\n            return this.#tokenizeIdentOrKeyword();\n        }\n        if (isNumber(this.#next))\n            return this.#tokenizeNumber();\n        if (this.#next === 46 /* . */)\n            return this.#tokenizeDot();\n        if (this.#next === 44 /* , */)\n            return this.#tokenizeComma();\n        if (this.#next === 58 /* : */)\n            return this.#tokenizeColon();\n        if (isOperator(this.#next))\n            return this.#tokenizeOperator();\n        if (_isGrouper(this.#next))\n            return this.#tokenizeGrouper();\n        // no match, should be end of input\n        this.#advance();\n        if (this.#next !== undefined) {\n            throw new Error(`Expected end of input, got ${this.#next}`);\n        }\n        return undefined;\n    }\n    #advance(resetTokenStart) {\n        this.#index++;\n        if (this.#index < this.#input.length) {\n            this.#next = this.#input.charCodeAt(this.#index);\n            if (resetTokenStart === true) {\n                this.#tokenStart = this.#index;\n            }\n        }\n        else {\n            this.#next = undefined;\n        }\n    }\n    #getValue(lookahead = 0) {\n        const v = this.#input.substring(this.#tokenStart, this.#index + lookahead);\n        if (lookahead === 0) {\n            this.#clearValue();\n        }\n        return v;\n    }\n    #clearValue() {\n        this.#tokenStart = this.#index;\n    }\n    #tokenizeString() {\n        const _us = 'unterminated string';\n        const quoteChar = this.#next;\n        this.#advance(true);\n        while (this.#next !== quoteChar) {\n            if (this.#next === undefined)\n                throw new Error(_us);\n            if (this.#next === 92 /* \\ */) {\n                this.#advance();\n                if (this.#next === undefined)\n                    throw new Error(_us);\n            }\n            this.#advance();\n        }\n        const t = token(Kind.STRING, escapeString(this.#getValue()));\n        this.#advance();\n        return t;\n    }\n    #tokenizeIdentOrKeyword() {\n        // This do/while loops assumes isIdentifier(this._next!), so it must only\n        // be called if isIdentOrKeywordStart(this._next!) has returned true.\n        do {\n            this.#advance();\n        } while (isIdentifier(this.#next));\n        const value = this.#getValue();\n        const kind = isKeyword(value) ? Kind.KEYWORD : Kind.IDENTIFIER;\n        return token(kind, value);\n    }\n    #tokenizeNumber() {\n        // This do/while loops assumes isNumber(this._next!), so it must only\n        // be called if isNumber(this._next!) has returned true.\n        do {\n            this.#advance();\n        } while (isNumber(this.#next));\n        if (this.#next === 46 /* . */)\n            return this.#tokenizeDot();\n        return token(Kind.INTEGER, this.#getValue());\n    }\n    #tokenizeDot() {\n        this.#advance();\n        if (isNumber(this.#next))\n            return this.#tokenizeFraction();\n        this.#clearValue();\n        return token(Kind.DOT, '.', POSTFIX_PRECEDENCE);\n    }\n    #tokenizeComma() {\n        this.#advance(true);\n        return token(Kind.COMMA, ',');\n    }\n    #tokenizeColon() {\n        this.#advance(true);\n        return token(Kind.COLON, ':');\n    }\n    #tokenizeFraction() {\n        // This do/while loops assumes isNumber(this._next!), so it must only\n        // be called if isNumber(this._next!) has returned true.\n        do {\n            this.#advance();\n        } while (isNumber(this.#next));\n        return token(Kind.DECIMAL, this.#getValue());\n    }\n    #tokenizeOperator() {\n        this.#advance();\n        let op = this.#getValue(2);\n        if (THREE_CHAR_OPS.indexOf(op) !== -1) {\n            this.#advance();\n            this.#advance();\n        }\n        else {\n            op = this.#getValue(1);\n            if (op === '=>') {\n                this.#advance();\n                return token(Kind.ARROW, op);\n            }\n            if (TWO_CHAR_OPS.indexOf(op) !== -1) {\n                this.#advance();\n            }\n        }\n        op = this.#getValue();\n        return token(Kind.OPERATOR, op, PRECEDENCE[op]);\n    }\n    #tokenizeGrouper() {\n        const value = String.fromCharCode(this.#next);\n        const t = token(Kind.GROUPER, value, PRECEDENCE[value]);\n        this.#advance(true);\n        return t;\n    }\n}\n//# sourceMappingURL=tokenizer.js.map","/*\n * @license\n * Portions Copyright (c) 2013, the Dart project authors.\n */\nimport { BINARY_OPERATORS, KEYWORDS, POSTFIX_PRECEDENCE, UNARY_OPERATORS, } from './constants.js';\nimport { Kind, Tokenizer } from './tokenizer.js';\nexport const parse = (expr, astFactory) => new Parser(expr, astFactory).parse();\nexport class Parser {\n    #kind;\n    #tokenizer;\n    #ast;\n    #token;\n    #value;\n    constructor(input, astFactory) {\n        this.#tokenizer = new Tokenizer(input);\n        this.#ast = astFactory;\n    }\n    parse() {\n        this.#advance();\n        return this.#parseExpression();\n    }\n    #advance(kind, value) {\n        if (!this._matches(kind, value)) {\n            throw new Error(`Expected kind ${kind} (${value}), was ${this.#token?.kind} (${this.#token?.value})`);\n        }\n        const t = this.#tokenizer.nextToken();\n        this.#token = t;\n        this.#kind = t?.kind;\n        this.#value = t?.value;\n    }\n    _matches(kind, value) {\n        return !((kind && this.#kind !== kind) || (value && this.#value !== value));\n    }\n    #parseExpression() {\n        if (!this.#token)\n            return this.#ast.empty();\n        const expr = this.#parseUnary();\n        return expr === undefined ? undefined : this.#parsePrecedence(expr, 0);\n    }\n    // #parsePrecedence and #parseBinary implement the precedence climbing\n    // algorithm as described in:\n    // http://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method\n    #parsePrecedence(left, precedence) {\n        if (left === undefined) {\n            throw new Error('Expected left to be defined.');\n        }\n        while (this.#token) {\n            if (this._matches(Kind.GROUPER, '(')) {\n                const args = this.#parseArguments();\n                left = this.#ast.invoke(left, undefined, args);\n            }\n            else if (this._matches(Kind.GROUPER, '[')) {\n                const indexExpr = this.#parseIndex();\n                left = this.#ast.index(left, indexExpr);\n            }\n            else if (this._matches(Kind.DOT)) {\n                this.#advance();\n                const right = this.#parseUnary();\n                left = this.#makeInvokeOrGetter(left, right);\n            }\n            else if (this._matches(Kind.KEYWORD)) {\n                break;\n            }\n            else if (this._matches(Kind.OPERATOR) &&\n                this.#token.precedence >= precedence) {\n                left =\n                    this.#value === '?'\n                        ? this.#parseTernary(left)\n                        : this.#parseBinary(left, this.#token);\n            }\n            else {\n                break;\n            }\n        }\n        return left;\n    }\n    #makeInvokeOrGetter(left, right) {\n        if (right === undefined) {\n            throw new Error('expected identifier');\n        }\n        if (right.type === 'ID') {\n            return this.#ast.getter(left, right.value);\n        }\n        else if (right.type === 'Invoke' &&\n            right.receiver.type === 'ID') {\n            const method = right.receiver;\n            return this.#ast.invoke(left, method.value, right.arguments);\n        }\n        else {\n            throw new Error(`expected identifier: ${right}`);\n        }\n    }\n    #parseBinary(left, op) {\n        if (BINARY_OPERATORS.indexOf(op.value) === -1) {\n            throw new Error(`unknown operator: ${op.value}`);\n        }\n        this.#advance();\n        let right = this.#parseUnary();\n        while ((this.#kind === Kind.OPERATOR ||\n            this.#kind === Kind.DOT ||\n            this.#kind === Kind.GROUPER) &&\n            this.#token.precedence > op.precedence) {\n            right = this.#parsePrecedence(right, this.#token.precedence);\n        }\n        return this.#ast.binary(left, op.value, right);\n    }\n    #parseUnary() {\n        if (this._matches(Kind.OPERATOR)) {\n            const value = this.#value;\n            this.#advance();\n            // handle unary + and - on numbers as part of the literal, not as a\n            // unary operator\n            if (value === '+' || value === '-') {\n                if (this._matches(Kind.INTEGER)) {\n                    return this.#parseInteger(value);\n                }\n                else if (this._matches(Kind.DECIMAL)) {\n                    return this.#parseDecimal(value);\n                }\n            }\n            if (UNARY_OPERATORS.indexOf(value) === -1)\n                throw new Error(`unexpected token: ${value}`);\n            const expr = this.#parsePrecedence(this.#parsePrimary(), POSTFIX_PRECEDENCE);\n            return this.#ast.unary(value, expr);\n        }\n        return this.#parsePrimary();\n    }\n    #parseTernary(condition) {\n        this.#advance(Kind.OPERATOR, '?');\n        const trueExpr = this.#parseExpression();\n        this.#advance(Kind.COLON);\n        const falseExpr = this.#parseExpression();\n        return this.#ast.ternary(condition, trueExpr, falseExpr);\n    }\n    #parsePrimary() {\n        switch (this.#kind) {\n            case Kind.KEYWORD:\n                const keyword = this.#value;\n                if (keyword === 'this') {\n                    this.#advance();\n                    // TODO(justin): return keyword node\n                    return this.#ast.id(keyword);\n                }\n                else if (KEYWORDS.indexOf(keyword) !== -1) {\n                    throw new Error(`unexpected keyword: ${keyword}`);\n                }\n                throw new Error(`unrecognized keyword: ${keyword}`);\n            case Kind.IDENTIFIER:\n                return this.#parseInvokeOrIdentifier();\n            case Kind.STRING:\n                return this.#parseString();\n            case Kind.INTEGER:\n                return this.#parseInteger();\n            case Kind.DECIMAL:\n                return this.#parseDecimal();\n            case Kind.GROUPER:\n                if (this.#value === '(') {\n                    return this.#parseParenOrFunction();\n                }\n                else if (this.#value === '{') {\n                    return this.#parseMap();\n                }\n                else if (this.#value === '[') {\n                    return this.#parseList();\n                }\n                return undefined;\n            case Kind.COLON:\n                throw new Error('unexpected token \":\"');\n            default:\n                return undefined;\n        }\n    }\n    #parseList() {\n        const items = [];\n        do {\n            this.#advance();\n            if (this._matches(Kind.GROUPER, ']'))\n                break;\n            items.push(this.#parseExpression());\n        } while (this._matches(Kind.COMMA));\n        this.#advance(Kind.GROUPER, ']');\n        return this.#ast.list(items);\n    }\n    #parseMap() {\n        const entries = {};\n        do {\n            this.#advance();\n            if (this._matches(Kind.GROUPER, '}'))\n                break;\n            const key = this.#value;\n            if (this._matches(Kind.STRING) || this._matches(Kind.IDENTIFIER)) {\n                this.#advance();\n            }\n            this.#advance(Kind.COLON);\n            entries[key] = this.#parseExpression();\n        } while (this._matches(Kind.COMMA));\n        this.#advance(Kind.GROUPER, '}');\n        return this.#ast.map(entries);\n    }\n    #parseInvokeOrIdentifier() {\n        const value = this.#value;\n        if (value === 'true') {\n            this.#advance();\n            return this.#ast.literal(true);\n        }\n        if (value === 'false') {\n            this.#advance();\n            return this.#ast.literal(false);\n        }\n        if (value === 'null') {\n            this.#advance();\n            return this.#ast.literal(null);\n        }\n        if (value === 'undefined') {\n            this.#advance();\n            return this.#ast.literal(undefined);\n        }\n        const identifier = this.#parseIdentifier();\n        const args = this.#parseArguments();\n        return !args ? identifier : this.#ast.invoke(identifier, undefined, args);\n    }\n    #parseIdentifier() {\n        if (!this._matches(Kind.IDENTIFIER)) {\n            throw new Error(`expected identifier: ${this.#value}`);\n        }\n        const value = this.#value;\n        this.#advance();\n        return this.#ast.id(value);\n    }\n    #parseArguments() {\n        if (!this._matches(Kind.GROUPER, '(')) {\n            return undefined;\n        }\n        const args = [];\n        do {\n            this.#advance();\n            if (this._matches(Kind.GROUPER, ')')) {\n                break;\n            }\n            const expr = this.#parseExpression();\n            args.push(expr);\n        } while (this._matches(Kind.COMMA));\n        this.#advance(Kind.GROUPER, ')');\n        return args;\n    }\n    #parseIndex() {\n        // console.assert(this.#matches(Kind.GROUPER, '['));\n        this.#advance();\n        const expr = this.#parseExpression();\n        this.#advance(Kind.GROUPER, ']');\n        return expr;\n    }\n    #parseParenOrFunction() {\n        const expressions = this.#parseArguments();\n        if (this._matches(Kind.ARROW)) {\n            this.#advance();\n            const body = this.#parseExpression();\n            const params = expressions?.map((e) => e.value) ?? [];\n            return this.#ast.arrowFunction(params, body);\n        }\n        else {\n            return this.#ast.paren(expressions[0]);\n        }\n    }\n    #parseString() {\n        const value = this.#ast.literal(this.#value);\n        this.#advance();\n        return value;\n    }\n    #parseInteger(prefix = '') {\n        const value = this.#ast.literal(parseInt(`${prefix}${this.#value}`, 10));\n        this.#advance();\n        return value;\n    }\n    #parseDecimal(prefix = '') {\n        const value = this.#ast.literal(parseFloat(`${prefix}${this.#value}`));\n        this.#advance();\n        return value;\n    }\n}\n//# sourceMappingURL=parser.js.map","/*\n * @license\n * Portions Copyright (c) 2013, the Dart project authors.\n */\nexport class DefaultAstFactory {\n    empty() {\n        return { type: 'Empty' };\n    }\n    // TODO(justinfagnani): just use a JS literal?\n    literal(value) {\n        return {\n            type: 'Literal',\n            value,\n        };\n    }\n    id(value) {\n        return {\n            type: 'ID',\n            value,\n        };\n    }\n    unary(operator, child) {\n        return {\n            type: 'Unary',\n            operator,\n            child,\n        };\n    }\n    binary(left, operator, right) {\n        return {\n            type: 'Binary',\n            operator,\n            left,\n            right,\n        };\n    }\n    getter(receiver, name) {\n        return {\n            type: 'Getter',\n            receiver,\n            name,\n        };\n    }\n    invoke(receiver, method, args) {\n        // TODO(justinfagnani): do this assertion in the parser\n        if (args === undefined) {\n            throw new Error('args');\n        }\n        return {\n            type: 'Invoke',\n            receiver,\n            method,\n            arguments: args,\n        };\n    }\n    paren(child) {\n        return {\n            type: 'Paren',\n            child,\n        };\n    }\n    index(receiver, argument) {\n        return {\n            type: 'Index',\n            receiver,\n            argument,\n        };\n    }\n    ternary(condition, trueExpr, falseExpr) {\n        return {\n            type: 'Ternary',\n            condition,\n            trueExpr,\n            falseExpr,\n        };\n    }\n    map(entries) {\n        return {\n            type: 'Map',\n            entries,\n        };\n    }\n    list(items) {\n        return {\n            type: 'List',\n            items,\n        };\n    }\n    arrowFunction(params, body) {\n        return {\n            type: 'ArrowFunction',\n            params,\n            body,\n        };\n    }\n}\n//# sourceMappingURL=ast_factory.js.map","/*\n * @license\n * Portions Copyright (c) 2013, the Dart project authors.\n */\nconst { hasOwn, fromEntries } = Object;\nconst _BINARY_OPERATORS = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '%': (a, b) => a % b,\n    '==': (a, b) => a == b,\n    '!=': (a, b) => a != b,\n    '===': (a, b) => a === b,\n    '!==': (a, b) => a !== b,\n    '>': (a, b) => a > b,\n    '>=': (a, b) => a >= b,\n    '<': (a, b) => a < b,\n    '<=': (a, b) => a <= b,\n    '||': (a, b) => a || b,\n    '&&': (a, b) => a && b,\n    '??': (a, b) => a ?? b,\n    '|': (a, f) => f(a),\n    '|>': (a, f) => f(a),\n};\nconst _UNARY_OPERATORS = {\n    '+': (a) => a,\n    '-': (a) => -a,\n    '!': (a) => !a,\n};\nexport class EvalAstFactory {\n    empty() {\n        // TODO(justinfagnani): return null instead?\n        return {\n            type: 'Empty',\n            evaluate(scope) {\n                return scope;\n            },\n            getIds(idents) {\n                return idents;\n            },\n        };\n    }\n    // TODO(justinfagnani): just use a JS literal?\n    literal(v) {\n        return {\n            type: 'Literal',\n            value: v,\n            evaluate(_scope) {\n                return this.value;\n            },\n            getIds(idents) {\n                return idents;\n            },\n        };\n    }\n    id(v) {\n        return {\n            type: 'ID',\n            value: v,\n            evaluate(scope) {\n                // TODO(justinfagnani): this prevents access to properties named 'this'\n                if (this.value === 'this')\n                    return scope;\n                return scope?.[this.value];\n            },\n            getIds(idents) {\n                idents.push(this.value);\n                return idents;\n            },\n        };\n    }\n    unary(op, expr) {\n        const f = _UNARY_OPERATORS[op];\n        return {\n            type: 'Unary',\n            operator: op,\n            child: expr,\n            evaluate(scope) {\n                return f(this.child.evaluate(scope));\n            },\n            getIds(idents) {\n                return this.child.getIds(idents);\n            },\n        };\n    }\n    binary(l, op, r) {\n        const f = _BINARY_OPERATORS[op];\n        return {\n            type: 'Binary',\n            operator: op,\n            left: l,\n            right: r,\n            evaluate(scope) {\n                if (this.operator === '=') {\n                    if (this.left.type !== 'ID' &&\n                        this.left.type !== 'Getter' &&\n                        this.left.type !== 'Index') {\n                        throw new Error(`Invalid assignment target: ${this.left}`);\n                    }\n                    const value = this.right.evaluate(scope);\n                    let receiver = undefined;\n                    let property;\n                    if (this.left.type === 'Getter') {\n                        receiver = this.left.receiver.evaluate(scope);\n                        property = this.left.name;\n                    }\n                    else if (this.left.type === 'Index') {\n                        receiver = this.left.receiver.evaluate(scope);\n                        property = this.left.argument.evaluate(scope);\n                    }\n                    else if (this.left.type === 'ID') {\n                        // TODO: the id could be a parameter\n                        receiver = scope;\n                        property = this.left.value;\n                    }\n                    return receiver === undefined\n                        ? undefined\n                        : (receiver[property] = value);\n                }\n                return f(this.left.evaluate(scope), this.right.evaluate(scope));\n            },\n            getIds(idents) {\n                this.left.getIds(idents);\n                this.right.getIds(idents);\n                return idents;\n            },\n        };\n    }\n    getter(g, n) {\n        return {\n            type: 'Getter',\n            receiver: g,\n            name: n,\n            evaluate(scope) {\n                return this.receiver.evaluate(scope)?.[this.name];\n            },\n            getIds(idents) {\n                this.receiver.getIds(idents);\n                return idents;\n            },\n        };\n    }\n    invoke(receiver, method, args) {\n        if (method != null && typeof method !== 'string') {\n            throw new Error('method not a string');\n        }\n        return {\n            type: 'Invoke',\n            receiver: receiver,\n            method: method,\n            arguments: args,\n            evaluate(scope) {\n                const receiver = this.receiver.evaluate(scope);\n                // TODO(justinfagnani): this might be wrong in cases where we're\n                // invoking a top-level function rather than a method. If method is\n                // defined on a nested scope, then we should probably set _this to null.\n                const _this = this.method ? receiver : (scope?.['this'] ?? scope);\n                const f = this.method ? receiver?.[method] : receiver;\n                const args = this.arguments ?? [];\n                const argValues = args.map((a) => a?.evaluate(scope));\n                return f?.apply?.(_this, argValues);\n            },\n            getIds(idents) {\n                this.receiver.getIds(idents);\n                this.arguments?.forEach((a) => a?.getIds(idents));\n                return idents;\n            },\n        };\n    }\n    paren(e) {\n        return e;\n    }\n    index(e, a) {\n        return {\n            type: 'Index',\n            receiver: e,\n            argument: a,\n            evaluate(scope) {\n                return this.receiver.evaluate(scope)?.[this.argument.evaluate(scope)];\n            },\n            getIds(idents) {\n                this.receiver.getIds(idents);\n                return idents;\n            },\n        };\n    }\n    ternary(c, t, f) {\n        return {\n            type: 'Ternary',\n            condition: c,\n            trueExpr: t,\n            falseExpr: f,\n            evaluate(scope) {\n                const c = this.condition.evaluate(scope);\n                if (c) {\n                    return this.trueExpr.evaluate(scope);\n                }\n                else {\n                    return this.falseExpr.evaluate(scope);\n                }\n            },\n            getIds(idents) {\n                this.condition.getIds(idents);\n                this.trueExpr.getIds(idents);\n                this.falseExpr.getIds(idents);\n                return idents;\n            },\n        };\n    }\n    map(entries) {\n        return {\n            type: 'Map',\n            entries: entries,\n            evaluate(scope) {\n                const map = {};\n                if (entries && this.entries) {\n                    for (const key in entries) {\n                        const val = this.entries[key];\n                        if (val) {\n                            map[key] = val.evaluate(scope);\n                        }\n                    }\n                }\n                return map;\n            },\n            getIds(idents) {\n                if (entries && this.entries) {\n                    for (const key in entries) {\n                        const val = this.entries[key];\n                        if (val) {\n                            val.getIds(idents);\n                        }\n                    }\n                }\n                return idents;\n            },\n        };\n    }\n    // TODO(justinfagnani): if the list is deeply literal\n    list(l) {\n        return {\n            type: 'List',\n            items: l,\n            evaluate(scope) {\n                return this.items?.map((a) => a?.evaluate(scope));\n            },\n            getIds(idents) {\n                this.items?.forEach((i) => i?.getIds(idents));\n                return idents;\n            },\n        };\n    }\n    arrowFunction(params, body) {\n        return {\n            type: 'ArrowFunction',\n            params,\n            body,\n            evaluate(scope) {\n                const params = this.params;\n                const body = this.body;\n                return function (...args) {\n                    // Create a nested scope for the function body with a proxy to getting\n                    // and setting parameters on a paramsObj, and setting other\n                    // identifiers on the scope. Without a proxy, attempting to set\n                    // properties on the outer scope would actually set them on the\n                    // inner scope due to JavaScript's assignment semantics.\n                    const paramsObj = fromEntries(params.map((p, i) => [p, args[i]]));\n                    const newScope = new Proxy(scope ?? {}, {\n                        set(target, prop, value) {\n                            if (hasOwn(paramsObj, prop)) {\n                                paramsObj[prop] = value;\n                            }\n                            return (target[prop] = value);\n                        },\n                        get(target, prop) {\n                            if (hasOwn(paramsObj, prop)) {\n                                return paramsObj[prop];\n                            }\n                            return target[prop];\n                        },\n                    });\n                    return body.evaluate(newScope);\n                };\n            },\n            getIds(idents) {\n                // Only return the _free_ variables in the body. Since arrow function\n                // parameters are the only way to introduce new variable names, we can\n                // assume that any variable in the body that isn't a parameter is free.\n                return this.body\n                    .getIds(idents)\n                    .filter((id) => !this.params.includes(id));\n            },\n        };\n    }\n}\n//# sourceMappingURL=eval.js.map"],"names":["KEYWORDS","UNARY_OPERATORS","BINARY_OPERATORS","PRECEDENCE","POSTFIX_PRECEDENCE","TWO_CHAR_OPS","THREE_CHAR_OPS","Kind","token","kind","value","precedence","isWhitespace","ch","isIdentOrKeywordStart","isIdentifier","isNumber","isKeyword","str","isQuote","isOperator","_isGrouper","escapeString","_match","group","Tokenizer","#input","#index","#tokenStart","#next","input","#advance","#tokenizeString","#tokenizeIdentOrKeyword","#tokenizeNumber","#tokenizeDot","#tokenizeComma","#tokenizeColon","#tokenizeOperator","#tokenizeGrouper","resetTokenStart","#getValue","lookahead","v","#clearValue","_us","quoteChar","t","#tokenizeFraction","op","parse","expr","astFactory","Parser","#kind","#tokenizer","#ast","#token","#value","#parseExpression","#parseUnary","#parsePrecedence","left","args","#parseArguments","indexExpr","#parseIndex","right","#makeInvokeOrGetter","#parseTernary","#parseBinary","method","#parseInteger","#parseDecimal","#parsePrimary","condition","trueExpr","falseExpr","keyword","#parseInvokeOrIdentifier","#parseString","#parseParenOrFunction","#parseMap","#parseList","items","entries","key","identifier","#parseIdentifier","expressions","body","params","e","prefix","DefaultAstFactory","operator","child","receiver","name","argument","hasOwn","fromEntries","_BINARY_OPERATORS","a","b","f","_UNARY_OPERATORS","EvalAstFactory","scope","idents","_scope","l","r","property","g","n","_this","argValues","c","map","val","i","paramsObj","p","newScope","target","prop","id"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}